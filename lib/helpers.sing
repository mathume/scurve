/* gets the image of a base element under psi */
proc PsiT(intvec baseexponent, ideal jacobIdeal, int p, int r, int N, int t){
  
  int q = p^r;
  poly psi = 0;
  intvec e = baseexponent;
  list IEP = IndicesExponentsPhisT(e, N, q, t);
  
  for(int j = N-1; j>=0; j--){

    //list IE = IndicesExponents(e, j, q, t, nalpha, alpha); //get exponents for F_k^(j+1)
    list IE = list(IEP[1][j+1], IEP[2][j+1], IEP[3][j+1]); //get exponents for F_k^(j+1)
    //validExponents(IE, j);
    bigint CJ = C(j, N);
    
    poly SigmaJ = Sigma(j, p, r, t, IE);//get sum for F_k^(j+1)
    
    psi = psi + CJ*SigmaJ;
//write(":a psi.tmp", string("j:", j, "   ", "psi prev: ", psi));
    psi = reduceStep(psi,jacobIdeal,j+1);
//write(":a psi.tmp", string("j:", j, "   ", "psi post: ", psi));

  }
  psi = psi/number((bigint(p)^(nvars(basering)-1)));
  
  write(":a psi.tmp", string("baseexponent=", baseexponent, " |-> ", psi));
  
  return(psi);
  
}
proc ReduceAllForPoleOrder(intvec baseexponent, ideal jacobIdeal, int p, int r, int poleOrder, int t){

	int q = p^r;
	poly psi = 0;
	intvec e = baseexponent;
	list IEP = IndicesExponentsPhisT(e, poleOrder, q, t);

	for(int j = poleOrder-1; j>=0; j--){
		
		list IE = list(IEP[1][j+1], IEP[2][j+1], IEP[3][j+1]);
		bigint DJ = D(j,poleOrder-1);
		poly SigmaJ = Sigma(j, p, r, t, IE);

		psi = psi + DJ*SigmaJ;

		psi = reduceStep(psi, jacobIdeal, j+1);
	}
	psi = psi/number((bigint(p)^(nvars(basering)-1)));

	return(psi);
}

proc D(int j, int n){
	bigint ret = 0;
	ret = ((-1)^j)*binomial(n, j);
	return(ret);
}

		
proc C(int j, int N){
   bigint ret = 0;
   ret = ((-1)^j)*binomial(N, j+1);
   return(ret);
}
proc Sigma(int j, int p, int r, int t, list indicesExponents){

  int upperbound = (p^r)*(j+1)-t;
  list indices = indicesExponents[1];
  list exponents = indicesExponents[2];
  list phiexps = indicesExponents[3];
  poly pol = 0;
  poly mon = 1;

  for(int i = 1; i <= size(indices); i++){
    mon = 1;
    intvec index = indices[i];
    intvec exponent = exponents[i];
    int phiexp = phiexps[i];
    
    number phi = T^phiexp;
    bigint multinom = multinomial(upperbound, index);
    number coeff = phi*multinom;
    
    for(int l = 1; l <= nvars(basering); l++){ //build the monomial
      mon  = mon*var(l)^exponent[l];
    }
    //write(":a summdeg.tmp", string("j=", j, "::deg(mon)=", deg(mon)));
    pol = pol + coeff * mon;
  }
  return(pol);
}
proc validExponents(list indicesExponents, int j){
   list exponents = indicesExponents[2];
   for(int i = 1; i<=size(exponents);i++){
      if(sumintvec(exponents[i]) != 5*(j+1) - 3){
         write(":a checkExponents.tmp", string(j, ":::", sumintvec(exponents[i])));      
   
      }
   }
}

////////////////////////////////////////////////////////////////
// ring independent

////////////////////////////////////////
/* returns the polynomial with coefficients as p-adic
 * approximations to precision N
 * needs singularcurve.lib
 */
proc padicApproxPoly(poly f, int p, int N){
   poly g = 0;
   for(int i = 1; i<=size(f); i++){
      g = g + padicApprox(leadcoef(f[i]),p,N)*leadmonom(f[i]);
   }
   return(g);
}


//////////////////////////////////////////
//////////////////////////////////////////
// returns v_T : QQ[T] -> ZZ
// Assumes QQ[T] = 0, T, dp;
proc PolyTadicOrder(poly n){
	def lowestDegMonom = n[size(n)];
	return(deg(lowestDegMonom));
}
//////////////////////////////////////////
//////////////////////////////////////////
// returns v_T : QQ(T) -> ZZ
// Assumes QQ(T) ~ (0,T), x..., dp;
// i.e. T is a number (switch ring)
proc NumberTadicOrder(number n){
	number zero = 0;
	if(n == zero){ return("Inf"); }
	def den = denominator(n);
	def num = numerator(n);
	def definition = string("poly num = ", num, ";poly den = ", den, ";");
	def prev = basering;
	ring TMP = 0, T, dp;
	execute(definition);
	def n = deg(num[size(num)]);
	def d = deg(den[size(den)]);
	int v = n - d;
	setring prev;
	return(v);
}


