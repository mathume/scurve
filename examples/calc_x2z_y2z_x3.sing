LIB "general.lib";
LIB "linalg.lib";
LIB "solve.lib";
LIB "../lib/singularcurve.lib";
execute(read("../lib/helpers.sing"));
LIB "matrix.lib";
LIB "poly.lib";
execute(read("./indices_exponents/x2z_y2z_x3.sing"));

ring Q = (0,T), (x,y,z), dp;

int p;
int r;
int k;
int d;
int N;
int DIM;
int vorz;
poly f;
int g;
ideal jf;
ideal bf;

proc setup(poly fpk, intvec degs){

	f = fpk;
	d = deg(f);

	/* get derivatives */
	ideal jf = jacob(f);

	/* get monomial base for quotientring qring qr = jf as vector space over rationals */
	ideal bf = kbase(std(jf));

	/* from base get only those which count (deg \in degs) pack them into another ideal; done separately in order to avoid ideal simplification */
	bf = extractIdeal(bf, degs);
	DIM = size(bf);

	return(list(d,jf,bf,DIM));
}

proc calc(int p, int r, int k, int N){
	
	/* for each base element calculate its image under psi where there's a partial reduction included */
	list psiList = list();
	for(int i = 0; i < DIM; i++){

	  poly basemonom = bf[DIM-i];
	  intvec e = leadexp(basemonom); //gets the exponents representing the monomial M in M/F_k**t * Omega
	  int t = ( sumintvec(e) + 3 ) / d;
	  
	  psiList = insert(psiList, Psi( e, jf, p, r, N, t, k ) );

	}

	/* get the matrix defining psi */
	matrix psiMatrix = getMatrix(bf, psiList);
	return(psiMatrix);
}

k = 3;
N = 3;
p = 5;
r = 1;
g = 0;
vorz = -1;
poly fpk = x^2*z + y^2*z + x3+(number(p)^k)*z^3;
list vals = setup(fpk,  intvec(0,3) ); //d*1-3, d*2-3
d = vals[1];
jf = vals[2];
bf = vals[3];
DIM = vals[4];
matrix PsiN = calc(p,1,k,N);
string L1 = getL1(PsiN,p);
list b1 = approximateBs(L1, p, r, g);//b_1,...,b_g
string L=LWithOrdinaryDP(b1,vorz,p,r);
